///////////////////////////////////////////////////////////////////
// tiny lib for drawing on screens 128x64 (SD1306 or SH1106)
//
//////////////////////////////////////////////////////////////////
#include <string.h>
#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "sdkconfig.h" // generated by "make menuconfig"
#include "tinyScreen128x64.h"
#include "esp_log.h"
#define LSSD 128
#define HSSD 64
#define ramSize 1024
#define tag "SH1106"
uint8_t ram[ramSize];


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
uint8_t font8x8_basic_tr[128][8] = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0000 (nul)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0001
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0002
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0003
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0004
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0005
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0006
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0007
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0008
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0009
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+000A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+000B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+000C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+000D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+000E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+000F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0010
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0011
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0012
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0013
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0014
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0015
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0016
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0017
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0018
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0019
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+001A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+001B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+001C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+001D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+001E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+001F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0020 (space)
    { 0x00, 0x00, 0x06, 0x5F, 0x5F, 0x06, 0x00, 0x00 },   // U+0021 (!)
    { 0x00, 0x03, 0x03, 0x00, 0x03, 0x03, 0x00, 0x00 },   // U+0022 (")
    { 0x14, 0x7F, 0x7F, 0x14, 0x7F, 0x7F, 0x14, 0x00 },   // U+0023 (#)
    { 0x24, 0x2E, 0x6B, 0x6B, 0x3A, 0x12, 0x00, 0x00 },   // U+0024 ($)
    { 0x46, 0x66, 0x30, 0x18, 0x0C, 0x66, 0x62, 0x00 },   // U+0025 (%)
    { 0x30, 0x7A, 0x4F, 0x5D, 0x37, 0x7A, 0x48, 0x00 },   // U+0026 (&)
    { 0x04, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 },   // U+0027 (')
    { 0x00, 0x1C, 0x3E, 0x63, 0x41, 0x00, 0x00, 0x00 },   // U+0028 (()
    { 0x00, 0x41, 0x63, 0x3E, 0x1C, 0x00, 0x00, 0x00 },   // U+0029 ())
    { 0x08, 0x2A, 0x3E, 0x1C, 0x1C, 0x3E, 0x2A, 0x08 },   // U+002A (*)
    { 0x08, 0x08, 0x3E, 0x3E, 0x08, 0x08, 0x00, 0x00 },   // U+002B (+)
    { 0x00, 0x80, 0xE0, 0x60, 0x00, 0x00, 0x00, 0x00 },   // U+002C (,)
    { 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00 },   // U+002D (-)
    { 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00 },   // U+002E (.)
    { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00 },   // U+002F (/)
    { 0x3E, 0x7F, 0x71, 0x59, 0x4D, 0x7F, 0x3E, 0x00 },   // U+0030 (0)
    { 0x40, 0x42, 0x7F, 0x7F, 0x40, 0x40, 0x00, 0x00 },   // U+0031 (1)
    { 0x62, 0x73, 0x59, 0x49, 0x6F, 0x66, 0x00, 0x00 },   // U+0032 (2)
    { 0x22, 0x63, 0x49, 0x49, 0x7F, 0x36, 0x00, 0x00 },   // U+0033 (3)
    { 0x18, 0x1C, 0x16, 0x53, 0x7F, 0x7F, 0x50, 0x00 },   // U+0034 (4)
    { 0x27, 0x67, 0x45, 0x45, 0x7D, 0x39, 0x00, 0x00 },   // U+0035 (5)
    { 0x3C, 0x7E, 0x4B, 0x49, 0x79, 0x30, 0x00, 0x00 },   // U+0036 (6)
    { 0x03, 0x03, 0x71, 0x79, 0x0F, 0x07, 0x00, 0x00 },   // U+0037 (7)
    { 0x36, 0x7F, 0x49, 0x49, 0x7F, 0x36, 0x00, 0x00 },   // U+0038 (8)
    { 0x06, 0x4F, 0x49, 0x69, 0x3F, 0x1E, 0x00, 0x00 },   // U+0039 (9)
    { 0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00 },   // U+003A (:)
    { 0x00, 0x80, 0xE6, 0x66, 0x00, 0x00, 0x00, 0x00 },   // U+003B (;)
    { 0x08, 0x1C, 0x36, 0x63, 0x41, 0x00, 0x00, 0x00 },   // U+003C (<)
    { 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00, 0x00 },   // U+003D (=)
    { 0x00, 0x41, 0x63, 0x36, 0x1C, 0x08, 0x00, 0x00 },   // U+003E (>)
    { 0x02, 0x03, 0x51, 0x59, 0x0F, 0x06, 0x00, 0x00 },   // U+003F (?)
    { 0x3E, 0x7F, 0x41, 0x5D, 0x5D, 0x1F, 0x1E, 0x00 },   // U+0040 (@)
    { 0x7C, 0x7E, 0x13, 0x13, 0x7E, 0x7C, 0x00, 0x00 },   // U+0041 (A)
    { 0x41, 0x7F, 0x7F, 0x49, 0x49, 0x7F, 0x36, 0x00 },   // U+0042 (B)
    { 0x1C, 0x3E, 0x63, 0x41, 0x41, 0x63, 0x22, 0x00 },   // U+0043 (C)
    { 0x41, 0x7F, 0x7F, 0x41, 0x63, 0x3E, 0x1C, 0x00 },   // U+0044 (D)
    { 0x41, 0x7F, 0x7F, 0x49, 0x5D, 0x41, 0x63, 0x00 },   // U+0045 (E)
    { 0x41, 0x7F, 0x7F, 0x49, 0x1D, 0x01, 0x03, 0x00 },   // U+0046 (F)
    { 0x1C, 0x3E, 0x63, 0x41, 0x51, 0x73, 0x72, 0x00 },   // U+0047 (G)
    { 0x7F, 0x7F, 0x08, 0x08, 0x7F, 0x7F, 0x00, 0x00 },   // U+0048 (H)
    { 0x00, 0x41, 0x7F, 0x7F, 0x41, 0x00, 0x00, 0x00 },   // U+0049 (I)
    { 0x30, 0x70, 0x40, 0x41, 0x7F, 0x3F, 0x01, 0x00 },   // U+004A (J)
    { 0x41, 0x7F, 0x7F, 0x08, 0x1C, 0x77, 0x63, 0x00 },   // U+004B (K)
    { 0x41, 0x7F, 0x7F, 0x41, 0x40, 0x60, 0x70, 0x00 },   // U+004C (L)
    { 0x7F, 0x7F, 0x0E, 0x1C, 0x0E, 0x7F, 0x7F, 0x00 },   // U+004D (M)
    { 0x7F, 0x7F, 0x06, 0x0C, 0x18, 0x7F, 0x7F, 0x00 },   // U+004E (N)
    { 0x1C, 0x3E, 0x63, 0x41, 0x63, 0x3E, 0x1C, 0x00 },   // U+004F (O)
    { 0x41, 0x7F, 0x7F, 0x49, 0x09, 0x0F, 0x06, 0x00 },   // U+0050 (P)
    { 0x1E, 0x3F, 0x21, 0x71, 0x7F, 0x5E, 0x00, 0x00 },   // U+0051 (Q)
    { 0x41, 0x7F, 0x7F, 0x09, 0x19, 0x7F, 0x66, 0x00 },   // U+0052 (R)
    { 0x26, 0x6F, 0x4D, 0x59, 0x73, 0x32, 0x00, 0x00 },   // U+0053 (S)
    { 0x03, 0x41, 0x7F, 0x7F, 0x41, 0x03, 0x00, 0x00 },   // U+0054 (T)
    { 0x7F, 0x7F, 0x40, 0x40, 0x7F, 0x7F, 0x00, 0x00 },   // U+0055 (U)
    { 0x1F, 0x3F, 0x60, 0x60, 0x3F, 0x1F, 0x00, 0x00 },   // U+0056 (V)
    { 0x7F, 0x7F, 0x30, 0x18, 0x30, 0x7F, 0x7F, 0x00 },   // U+0057 (W)
    { 0x43, 0x67, 0x3C, 0x18, 0x3C, 0x67, 0x43, 0x00 },   // U+0058 (X)
    { 0x07, 0x4F, 0x78, 0x78, 0x4F, 0x07, 0x00, 0x00 },   // U+0059 (Y)
    { 0x47, 0x63, 0x71, 0x59, 0x4D, 0x67, 0x73, 0x00 },   // U+005A (Z)
    { 0x00, 0x7F, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00 },   // U+005B ([)
    { 0x01, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00 },   // U+005C (\)
    { 0x00, 0x41, 0x41, 0x7F, 0x7F, 0x00, 0x00, 0x00 },   // U+005D (])
    { 0x08, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x08, 0x00 },   // U+005E (^)
    { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },   // U+005F (_)
    { 0x00, 0x00, 0x03, 0x07, 0x04, 0x00, 0x00, 0x00 },   // U+0060 (`)
    { 0x20, 0x74, 0x54, 0x54, 0x3C, 0x78, 0x40, 0x00 },   // U+0061 (a)
    { 0x41, 0x7F, 0x3F, 0x48, 0x48, 0x78, 0x30, 0x00 },   // U+0062 (b)
    { 0x38, 0x7C, 0x44, 0x44, 0x6C, 0x28, 0x00, 0x00 },   // U+0063 (c)
    { 0x30, 0x78, 0x48, 0x49, 0x3F, 0x7F, 0x40, 0x00 },   // U+0064 (d)
    { 0x38, 0x7C, 0x54, 0x54, 0x5C, 0x18, 0x00, 0x00 },   // U+0065 (e)
    { 0x48, 0x7E, 0x7F, 0x49, 0x03, 0x02, 0x00, 0x00 },   // U+0066 (f)
    { 0x98, 0xBC, 0xA4, 0xA4, 0xF8, 0x7C, 0x04, 0x00 },   // U+0067 (g)
    { 0x41, 0x7F, 0x7F, 0x08, 0x04, 0x7C, 0x78, 0x00 },   // U+0068 (h)
    { 0x00, 0x44, 0x7D, 0x7D, 0x40, 0x00, 0x00, 0x00 },   // U+0069 (i)
    { 0x60, 0xE0, 0x80, 0x80, 0xFD, 0x7D, 0x00, 0x00 },   // U+006A (j)
    { 0x41, 0x7F, 0x7F, 0x10, 0x38, 0x6C, 0x44, 0x00 },   // U+006B (k)
    { 0x00, 0x41, 0x7F, 0x7F, 0x40, 0x00, 0x00, 0x00 },   // U+006C (l)
    { 0x7C, 0x7C, 0x18, 0x38, 0x1C, 0x7C, 0x78, 0x00 },   // U+006D (m)
    { 0x7C, 0x7C, 0x04, 0x04, 0x7C, 0x78, 0x00, 0x00 },   // U+006E (n)
    { 0x38, 0x7C, 0x44, 0x44, 0x7C, 0x38, 0x00, 0x00 },   // U+006F (o)
    { 0x84, 0xFC, 0xF8, 0xA4, 0x24, 0x3C, 0x18, 0x00 },   // U+0070 (p)
    { 0x18, 0x3C, 0x24, 0xA4, 0xF8, 0xFC, 0x84, 0x00 },   // U+0071 (q)
    { 0x44, 0x7C, 0x78, 0x4C, 0x04, 0x1C, 0x18, 0x00 },   // U+0072 (r)
    { 0x48, 0x5C, 0x54, 0x54, 0x74, 0x24, 0x00, 0x00 },   // U+0073 (s)
    { 0x00, 0x04, 0x3E, 0x7F, 0x44, 0x24, 0x00, 0x00 },   // U+0074 (t)
    { 0x3C, 0x7C, 0x40, 0x40, 0x3C, 0x7C, 0x40, 0x00 },   // U+0075 (u)
    { 0x1C, 0x3C, 0x60, 0x60, 0x3C, 0x1C, 0x00, 0x00 },   // U+0076 (v)
    { 0x3C, 0x7C, 0x70, 0x38, 0x70, 0x7C, 0x3C, 0x00 },   // U+0077 (w)
    { 0x44, 0x6C, 0x38, 0x10, 0x38, 0x6C, 0x44, 0x00 },   // U+0078 (x)
    { 0x9C, 0xBC, 0xA0, 0xA0, 0xFC, 0x7C, 0x00, 0x00 },   // U+0079 (y)
    { 0x4C, 0x64, 0x74, 0x5C, 0x4C, 0x64, 0x00, 0x00 },   // U+007A (z)
    { 0x08, 0x08, 0x3E, 0x77, 0x41, 0x41, 0x00, 0x00 },   // U+007B ({)
    { 0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00 },   // U+007C (|)
    { 0x41, 0x41, 0x77, 0x3E, 0x08, 0x08, 0x00, 0x00 },   // U+007D (})
    { 0x02, 0x03, 0x01, 0x03, 0x02, 0x03, 0x01, 0x00 },   // U+007E (~)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }    // U+007F
};

////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////
//integer square root...
//////////////////////////////////////////////////////////
int isqrt(int v)
{
int i;
if(v == 0) return 0;
i = 1;
while(i*i < v) i++;
return i;
}

int I2C_NUM_CH;
int OLED_I2C_ADDRESS;
uint8_t type    ;   // 0 => SSD1306  1 => SD1106
esp_err_t espRc;

//////////////////////////////////////////////////////////////
// initializations
//       i2c
//           pins SDA and SCL
//           number (0 or 1)
//           address (0x3C, 0x3D, or...)
//       type of 128x64 screen (0=> SSD1306 1=>SH1106)
//
///////////////////////////////////////////////////////////////

void tinySsd_init(int sda, int scl, int ch, int add, int t) {

  I2C_NUM_CH = ch;
  OLED_I2C_ADDRESS = add;
  type = (uint8_t) t;
       
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = sda,
		.scl_io_num = scl,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = 1000000
	};
	i2c_param_config(I2C_NUM_CH, &i2c_config);
	i2c_driver_install(I2C_NUM_CH, I2C_MODE_MASTER, 0, 0, 0);

// init screen

   sendCom(0xAE);   // Display OFF
   sendCom(0xD5);   // clock div
   sendCom(0x80);
   sendCom(0xA8);   // Set multiplex
   sendCom(0x3F);
   sendCom(0xD3);   // Set display offset (=0)
   sendCom(0x00);
   sendCom(0x40);   // Set start line (=0)
   sendCom(0x8D);   // Set charge pump
   sendCom(0x14);   
   sendCom(0x20);   // Set page addressing mode
   sendCom(0x02);
   sendCom(0xC8);   // Set remapped scan mode (reverse n-1 to 0)
   sendCom(0xA0);   // Set segment remap (col0 => SEG0)
   sendCom(0xDA);   // Set Com pins config
   sendCom(0x12);
   sendCom(0x81);   // Set contrast
   sendCom(0x7F);
   sendCom(0xD9);   // hardware init
   sendCom(0x22);
   sendCom(0xDB);
   sendCom(0x40);
   sendCom(0xA4);   // follow ram content
   sendCom(0xA6);   // Set normal display (1 in ram => point ON on display)
   sendCom(0xAF);   // Display ON
}

/////////////////////////////////////////////////////////////////////////
// send command (one byte)
//
//
//////////////////////////////////////////////////////////////////////////
void sendCom(uint8_t c)
{
  i2c_cmd_handle_t cmd = i2c_cmd_link_create();
  i2c_master_start(cmd);
  i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
  i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
  i2c_master_write_byte(cmd, c, true);
  i2c_master_stop(cmd);
  espRc = i2c_master_cmd_begin(I2C_NUM_CH, cmd, 100/portTICK_PERIOD_MS);
  if (espRc == ESP_OK) {
    ESP_LOGI(tag, "OLED configured successfully");
  } else {
    ESP_LOGE(tag, "OLED configuration failed. code: 0x%.2X", espRc);
  }
  i2c_cmd_link_delete(cmd);
}


/////////////////////////////////////////////////////////////////////////
//
// draw one point (x, y)
//    0<x<63  0<y<127
//////////////////////////////////////////////////////////////////////////
void drawPoint(int x, int y)
{
int i;
if((x>63) || (x<0))return;
if((y>127) || (y<0))return;

i = y + ((x >> 3) << 7);
ram[i] = ram[i] | 1 << (x % 8);
}

//////////////////////////////////////////////////////////////////////////
// clear buffer
/////////////////////////////////////////////////////////////////////////
void clearBuffer()
{
int i;
for(i=0; i<ramSize; i++)ram[i] = 0;
}

/////////////////////////////////////////////////////////////////////////////////
// draws an horizontal line from point (x, y) to point(x, y+l)
/////////////////////////////////////////////////////////////////////////////////
void drawHLine(int x, int y, int l)
{
int i;
for(i=0; i<l; i++)drawPoint(x,y+i);
}

////////////////////////////////////////////////////////////////////////////////
// draws a vertical line from point(x,y) to point(x+l, y)
////////////////////////////////////////////////////////////////////////////////
void drawVLine(int x, int y, int l)
{
int i;
for(i=0; i<l; i++)drawPoint(x+i,y);
}

////////////////////////////////////////////////////////////////////////////////
// draws a frame from point (x, y) (upper left)
////////////////////////////////////////////////////////////////////////////////
void drawFrame(int x, int y, int h, int w)
{
drawHLine(x, y, w);
drawVLine(x, y, h);
drawHLine(x+h, y, w);
drawVLine(x, y+w, h);
}
/////////////////////////////////////////////////////////////////////////////////
// like drawFrame but all the points inside are ON
//////////////////////////////////////////////////////////////////////////////////

void drawRectangle(int x, int y, int h, int w)
{
for(int i=0; i<=h; i++) drawHLine(x+i, y, w);
}

/////////////////////////////////////////////////////////////////////////////////
// draws a sound index in a frame (x, y, L, H) with N different values  and V actual value
///////////////////////////////////////////////////////////////////////////////////////

void drawIndex(int x, int y, int L, int H, int N, int V)
{
  int DL, DH;
  DL = L / N;
  DH = H / N;
  if(V > N) V = N;
  if(V < 0) V = 0;
  for(int i=0;i<N;i++)
  {
    if(i >= V)drawFrame(x+H-DH*(i+1),y+DL*i,DH*(i+1), DL);
    else drawRectangle(x+H-DH*(i+1),y+DL*i,DH*(i+1), DL);
  }
}

///////////////////////////////////////////////////////////////////////////////////////
// another index
////////////////////////////////////////////////////////////////////////////////////////
void drawIndexb(int x, int y, int L, int H, int N, int V)
{
  int DL;
  DL = L / N;
  if(V > N) V = N;
  if(V < 0) V = 0;
  drawFrame(x, y, L, H);
  drawRectangle(x+(N-V)*DL, y, V*DL, H);
}








////////////////////////////////////////////////////////
// draws an empty circle
////////////////////////////////////////////////////////
void drawCircle(int x, int y, int r)
{
int i;
int d;
for(i=0; i<r; i++)
{
d = isqrt(r*r - i*i);
drawPoint(x+i, y+d);
drawPoint(x+i, y-d);
drawPoint(x-i, y+d);
drawPoint(x-i, y-d);
}
for(i=0; i<r; i++)
{
d = isqrt(r*r - i*i);
drawPoint(x+d, y+i);
drawPoint(x-d, y+i);
drawPoint(x+d, y-i);
drawPoint(x-d, y-i);
}
}

//////////////////////////////////////////////////////////////////////////////
// draws half circle (left)
/////////////////////////////////////////////////////////////////////////////////
void drawCircleL(int x, int y, int r)
{
int i;
int d;
for(i=0; i<r; i++)
{
d = isqrt(r*r - i*i);
drawPoint(x+i, y-d);
drawPoint(x-i, y-d);
}
for(i=0; i<r; i++)
{
d = isqrt(r*r - i*i);
drawPoint(x+d, y-i);
drawPoint(x-d, y-i);
}
}

//////////////////////////////////////////////////////////////////////////////////////////
// draws half circle (right)
/////////////////////////////////////////////////////////////////////////////////////////

void drawCircleR(int x, int y, int r)
{
int i;
int d;
for(i=0; i<r; i++)
{
d = isqrt(r*r - i*i);
drawPoint(x+i, y+d);
drawPoint(x-i, y+d);
}
for(i=0; i<r; i++)
{
d = isqrt(r*r - i*i);
drawPoint(x+d, y+i);
drawPoint(x-d, y+i);
}
}
///////////////////////////////////////////////////////////////
// draws a rounded frame
///////////////////////////////////////////////////////////////
void drawFrameC(int x, int y, int h, int w)
{
drawHLine(x, y, w);
drawHLine(x+h, y, w);
drawCircleL(x+h/2, y, h/2);
drawCircleR(x+h/2, y+w, h/2);
                                       
}






///////////////////////////////////////////////////////////////////
// draws a string of characters 
//             8x8 
//           Horizontal
//           fron point(x, y)
////////////////////////////////////////////////////////////////////
void drawStr(int x, int y, char* s)
{
int i;
int j,k;

i = y + ((x >> 3) << 7);
for(j=0; j < strlen(s); j++)
{
for(k=0;k<8;k++)
{
ram[i++] = font8x8_basic_tr[(uint8_t)s[j]][k];
}
}
}

//////////////////////////////////////////////////////////////////////////
// like drawStr but centered on line x
////////////////////////////////////////////////////////////////////////////
void drawStrC(int x,char* s)
{

int y ;
if(strlen(s) > 16) s[16] = 0;
y = (128 - strlen(s)*8) / 2;
drawStr(x, y, s);
}
/////////////////////////////////////////////////////////////////////////////////
// like drawStr but with 16x16 characters
//
////////////////////////////////////////////////////////////////////////////////
void drawBigChar(int x, int y, char c)
{
uint8_t v;
for(int i=0;i<8;i++)
{
   v = font8x8_basic_tr[(uint8_t)c][i];
   for(int j=0;j<8;j++)
   {
      if(((v>>j) & 0x01) == 1)
      {
       drawPoint(x+2*j, y+2*i);
       drawPoint(x+1+2*j, y+2*i);
       drawPoint(x+2*j, y+1+2*i);
       drawPoint(x+1+2*j, y+1+2*i);
      }
   }
}
}
/////////////////////////////////////////////////////////////////////////////////////////
// like drawStrC but with 16x16 char
///////////////////////////////////////////////////////////////////////////////////////
void drawBigStrC(int x, char *s)
{
int y;
if(strlen(s) > 8) s[8] = 0;
y = (128 - strlen(s)*16) / 2;
for(int i=0;i<strlen(s);i++) drawBigChar(x, y+16*i, s[i]);

}

///////////////////////////////////////////////////////////////////////////////////////
// local
// sends values from program buffer to internal display ram (one page)
////////////////////////////////////////////////////////////////////////////////////////

void sendPage(uint8_t p)
{
  sendCom(0x20);
  sendCom(0x02);
  sendCom(0xB0+p);
  sendCom(0x00 + type << 1); // 0x00 pour SSD1306  0x02 pour SH1106
  sendCom(0x10);

 
  for(int16_t j= LSSD-1; j>=0;j=j-16)
  {
     i2c_cmd_handle_t cmd = i2c_cmd_link_create();
     i2c_master_start(cmd);
     i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
     i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
     for(int k=0;k<16;k++)i2c_master_write_byte(cmd,ram[p*LSSD+j-k], true);
     i2c_master_stop(cmd);
     espRc = i2c_master_cmd_begin(I2C_NUM_CH, cmd, 100/portTICK_PERIOD_MS);
     if (espRc == ESP_OK) {
       ESP_LOGI(tag, "OLED configured successfully");
     } 
     else {
       ESP_LOGE(tag, "OLED configuration failed. code: 0x%.2X", espRc);
      }
     i2c_cmd_link_delete(cmd);
  }
  
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
// public
// sends values from program buffer to internal display ram (8 pages)
////////////////////////////////////////////////////////////////////////////////////////

void sendBuffer(void)
{
  for(int8_t i=0;i<(HSSD/8);i++) sendPage(i);
}
